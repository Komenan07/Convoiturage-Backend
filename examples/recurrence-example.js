// Exemple d'utilisation du service de r√©currence des trajets
const mongoose = require('mongoose');
const RecurrenceService = require('../services/recurrenceService');
const Trajet = require('../models/Trajet');

console.log('üöÄ Exemple d\'utilisation du service de r√©currence des trajets\n');

// Exemple 1: Cr√©ation d'un trajet r√©current et g√©n√©ration des instances
async function exempleCreationTrajetRecurrent() {
  console.log('üìù Exemple 1: Cr√©ation d\'un trajet r√©current');
  
  try {
    // Cr√©er un trajet r√©current (trajet de travail quotidien)
    const trajetRecurrent = new Trajet({
      conducteurId: new mongoose.Types.ObjectId(),
      pointDepart: {
        nom: 'R√©sidence Cocody',
        adresse: 'Cocody, Abidjan',
        commune: 'Cocody',
        quartier: 'Riviera 2',
        coordonnees: {
          type: 'Point',
          coordinates: [-3.9900, 5.3500]
        }
      },
      pointArrivee: {
        nom: 'Bureau Plateau',
        adresse: 'Plateau, Abidjan',
        commune: 'Plateau',
        quartier: 'Centre-ville',
        coordonnees: {
          type: 'Point',
          coordinates: [-4.0083, 5.3600]
        }
      },
      dateDepart: new Date('2024-01-01'),
      heureDepart: '07:30',
      heureArriveePrevue: '08:15',
      dureeEstimee: 45,
      distance: 8.2,
      prixParPassager: 400,
      nombrePlacesDisponibles: 2,
      nombrePlacesTotal: 3,
      typeTrajet: 'RECURRENT',
      recurrence: {
        jours: ['LUNDI', 'MARDI', 'MERCREDI', 'JEUDI', 'VENDREDI'],
        dateFinRecurrence: new Date('2024-12-31')
      },
      vehiculeUtilise: {
        marque: 'Renault',
        modele: 'Clio',
        couleur: 'Bleu',
        immatriculation: 'AB-456-EF',
        nombrePlaces: 3
      },
      preferences: {
        accepteBagages: true,
        typeBagages: 'PETIT',
        musique: true,
        conversation: 'LIBRE',
        fumeur: false
      },
      commentaireConducteur: 'Trajet quotidien pour le travail, d√©part t√¥t le matin'
    });
    
    console.log('   ‚úÖ Trajet r√©current cr√©√©:');
    console.log(`     D√©part: ${trajetRecurrent.pointDepart.nom} ‚Üí ${trajetRecurrent.pointArrivee.nom}`);
    console.log(`     Jours: ${trajetRecurrent.recurrence.jours.join(', ')}`);
    console.log(`     Heure: ${trajetRecurrent.heureDepart}`);
    console.log(`     Prix: ${trajetRecurrent.prixParPassager} FCFA`);
    console.log(`     Jusqu\'au: ${trajetRecurrent.recurrence.dateFinRecurrence.toLocaleDateString('fr-FR')}\n`);
    
    return trajetRecurrent;
    
  } catch (error) {
    console.log('‚ùå Erreur:', error.message);
    return null;
  }
}

// Exemple 2: G√©n√©ration automatique des instances pour un mois
async function exempleGenerationInstances() {
  console.log('üîÑ Exemple 2: G√©n√©ration automatique des instances');
  
  try {
    const trajetRecurrent = await exempleCreationTrajetRecurrent();
    if (!trajetRecurrent) return;
    
    // G√©n√©rer les instances pour le mois de f√©vrier
    const dateDebut = new Date('2024-02-01');
    const dateFin = new Date('2024-02-29');
    
    console.log(`   üìÖ G√©n√©ration des instances pour f√©vrier 2024...`);
    
    // Simuler la g√©n√©ration (sans base de donn√©es)
    const datesInstances = RecurrenceService.genererDatesRecurrence(
      trajetRecurrent.recurrence.jours,
      dateDebut,
      dateFin,
      trajetRecurrent.heureDepart
    );
    
    console.log(`   ‚úÖ ${datesInstances.length} instances g√©n√©r√©es`);
    
    // Afficher les premi√®res instances
    console.log('   Premi√®res instances:');
    datesInstances.slice(0, 5).forEach((date, index) => {
      const jourSemaine = date.toLocaleDateString('fr-FR', { weekday: 'long' });
      console.log(`     ${index + 1}. ${jourSemaine} ${date.toLocaleDateString('fr-FR')} √† ${trajetRecurrent.heureDepart}`);
    });
    
    if (datesInstances.length > 5) {
      console.log(`     ... et ${datesInstances.length - 5} autres instances`);
    }
    
    console.log(`   üí∞ Revenus potentiels: ${datesInstances.length * trajetRecurrent.prixParPassager * 2} FCFA (2 passagers)\n`);
    
  } catch (error) {
    console.log('‚ùå Erreur:', error.message);
  }
}

// Exemple 3: Modification de la r√©currence
async function exempleModificationRecurrence() {
  console.log('üìù Exemple 3: Modification de la r√©currence');
  
  try {
    const trajetRecurrent = await exempleCreationTrajetRecurrent();
    if (!trajetRecurrent) return;
    
    console.log('   Configuration initiale:');
    console.log(`     Jours: ${trajetRecurrent.recurrence.jours.join(', ')}`);
    console.log(`     Date fin: ${trajetRecurrent.recurrence.dateFinRecurrence.toLocaleDateString('fr-FR')}`);
    
    // Modifier la r√©currence (ajouter le samedi, changer la date de fin)
    const nouvelleRecurrence = {
      jours: ['LUNDI', 'MARDI', 'MERCREDI', 'JEUDI', 'VENDREDI', 'SAMEDI'],
      dateFinRecurrence: new Date('2024-06-30')
    };
    
    console.log('\n   Nouvelle configuration:');
    console.log(`     Jours: ${nouvelleRecurrence.jours.join(', ')}`);
    console.log(`     Date fin: ${nouvelleRecurrence.dateFinRecurrence.toLocaleDateString('fr-FR')}`);
    
    // Calculer l'impact sur le nombre d'instances
    const anciennesInstances = RecurrenceService.genererDatesRecurrence(
      trajetRecurrent.recurrence.jours,
      new Date('2024-02-01'),
      new Date('2024-06-30'),
      trajetRecurrent.heureDepart
    );
    
    const nouvellesInstances = RecurrenceService.genererDatesRecurrence(
      nouvelleRecurrence.jours,
      new Date('2024-02-01'),
      nouvelleRecurrence.dateFinRecurrence,
      trajetRecurrent.heureDepart
    );
    
    console.log('\n   Impact de la modification:');
    console.log(`     Instances avant: ${anciennesInstances.length}`);
    console.log(`     Instances apr√®s: ${nouvellesInstances.length}`);
    console.log(`     Diff√©rence: +${nouvellesInstances.length - anciennesInstances.length} instances`);
    console.log(`     Revenus suppl√©mentaires: ${(nouvellesInstances.length - anciennesInstances.length) * trajetRecurrent.prixParPassager * 2} FCFA\n`);
    
  } catch (error) {
    console.log('‚ùå Erreur:', error.message);
  }
}

// Exemple 4: Gestion des exceptions (vacances, jours f√©ri√©s)
async function exempleGestionExceptions() {
  console.log('üö´ Exemple 4: Gestion des exceptions');
  
  try {
    const trajetRecurrent = await exempleCreationTrajetRecurrent();
    if (!trajetRecurrent) return;
    
    // D√©finir des p√©riodes d'exception
    const exceptions = [
      { debut: new Date('2024-04-01'), fin: new Date('2024-04-05'), raison: 'Vacances de P√¢ques' },
      { debut: new Date('2024-07-15'), fin: new Date('2024-08-15'), raison: 'Vacances d\'√©t√©' },
      { debut: new Date('2024-12-23'), fin: new Date('2024-12-31'), raison: 'Vacances de No√´l' }
    ];
    
    console.log('   P√©riodes d\'exception d√©finies:');
    exceptions.forEach((exception, index) => {
      console.log(`     ${index + 1}. ${exception.debut.toLocaleDateString('fr-FR')} ‚Üí ${exception.fin.toLocaleDateString('fr-FR')} (${exception.raison})`);
    });
    
    // Calculer les instances en tenant compte des exceptions
    const dateDebut = new Date('2024-01-01');
    const dateFin = new Date('2024-12-31');
    
    let datesInstances = RecurrenceService.genererDatesRecurrence(
      trajetRecurrent.recurrence.jours,
      dateDebut,
      dateFin,
      trajetRecurrent.heureDepart
    );
    
    // Filtrer les dates d'exception
    const instancesFiltrees = datesInstances.filter(date => {
      return !exceptions.some(exception => 
        date >= exception.debut && date <= exception.fin
      );
    });
    
    console.log('\n   Impact des exceptions:');
    console.log(`     Instances totales: ${datesInstances.length}`);
    console.log(`     Instances apr√®s filtrage: ${instancesFiltrees.length}`);
    console.log(`     Instances supprim√©es: ${datesInstances.length - instancesFiltrees.length}`);
    console.log(`     Revenus ajust√©s: ${instancesFiltrees.length * trajetRecurrent.prixParPassager * 2} FCFA\n`);
    
  } catch (error) {
    console.log('‚ùå Erreur:', error.message);
  }
}

// Exemple 5: Optimisation des trajets r√©currents
async function exempleOptimisation() {
  console.log('‚ö° Exemple 5: Optimisation des trajets r√©currents');
  
  try {
    const trajetRecurrent = await exempleCreationTrajetRecurrent();
    if (!trajetRecurrent) return;
    
    // Analyser diff√©rents sc√©narios de r√©currence
    const scenarios = [
      { nom: 'Travail uniquement', jours: ['LUNDI', 'MARDI', 'MERCREDI', 'JEUDI', 'VENDREDI'] },
      { nom: 'Travail + weekend', jours: ['LUNDI', 'MARDI', 'MERCREDI', 'JEUDI', 'VENDREDI', 'SAMEDI', 'DIMANCHE'] },
      { nom: 'Altern√©', jours: ['LUNDI', 'MERCREDI', 'VENDREDI'] },
      { nom: 'Flexible', jours: ['MARDI', 'JEUDI'] }
    ];
    
    console.log('   Analyse des sc√©narios de r√©currence:');
    
    const dateDebut = new Date('2024-02-01');
    const dateFin = new Date('2024-06-30');
    
    scenarios.forEach(scenario => {
      const instances = RecurrenceService.genererDatesRecurrence(
        scenario.jours,
        dateDebut,
        dateFin,
        trajetRecurrent.heureDepart
      );
      
      const revenus = instances.length * trajetRecurrent.prixParPassager * 2;
      const tauxOccupation = Math.min(100, (instances.length / 150) * 100); // 150 jours max sur la p√©riode
      
      console.log(`     ${scenario.nom}:`);
      console.log(`       Jours: ${scenario.jours.join(', ')}`);
      console.log(`       Instances: ${instances.length}`);
      console.log(`       Revenus: ${revenus} FCFA`);
      console.log(`       Taux occupation: ${tauxOccupation.toFixed(1)}%`);
      console.log('');
    });
    
    console.log('   üí° Recommandation: Sc√©nario "Travail uniquement" pour un bon √©quilibre revenus/qualit√© de vie\n');
    
  } catch (error) {
    console.log('‚ùå Erreur:', error.message);
  }
}

// Exemple 6: Maintenance et nettoyage
async function exempleMaintenance() {
  console.log('üßπ Exemple 6: Maintenance et nettoyage');
  
  try {
    console.log('   Op√©rations de maintenance:');
    
    // Nettoyage des anciennes instances
    const dateLimite = new Date('2024-01-01');
    console.log(`     1. Nettoyage des instances ant√©rieures √† ${dateLimite.toLocaleDateString('fr-FR')}`);
    
    // V√©rification des trajets r√©currents actifs
    console.log('     2. V√©rification des trajets r√©currents actifs');
    
    // Statistiques de r√©currence
    console.log('     3. G√©n√©ration des statistiques de r√©currence');
    
    // Optimisation des index
    console.log('     4. Optimisation des index de base de donn√©es');
    
    console.log('   ‚úÖ Maintenance planifi√©e et automatis√©e\n');
    
  } catch (error) {
    console.log('‚ùå Erreur:', error.message);
  }
}

// Fonction principale
async function runExamples() {
  try {
    await exempleCreationTrajetRecurrent();
    await exempleGenerationInstances();
    await exempleModificationRecurrence();
    await exempleGestionExceptions();
    await exempleOptimisation();
    await exempleMaintenance();
    
    console.log('üéØ Tous les exemples de r√©currence ex√©cut√©s avec succ√®s!');
    console.log('\nüìã R√©sum√© des fonctionnalit√©s d√©montr√©es:');
    console.log('   ‚úÖ Cr√©ation de trajets r√©currents');
    console.log('   ‚úÖ G√©n√©ration automatique des instances');
    console.log('   ‚úÖ Modification de la r√©currence');
    console.log('   ‚úÖ Gestion des exceptions (vacances, jours f√©ri√©s)');
    console.log('   ‚úÖ Optimisation des sc√©narios de r√©currence');
    console.log('   ‚úÖ Maintenance et nettoyage automatis√©s');
    
    console.log('\nüí° Cas d\'usage typiques:');
    console.log('   üöó Trajets domicile-travail quotidiens');
    console.log('   üè´ Transport scolaire r√©gulier');
    console.log('   üõí Courses hebdomadaires');
    console.log('   üè• Rendez-vous m√©dicaux r√©currents');
    console.log('   üé≠ Activit√©s culturelles mensuelles');
    
  } catch (error) {
    console.log('\nüí• Erreur lors de l\'ex√©cution des exemples:', error.message);
  }
}

// Ex√©cuter les exemples
runExamples();
