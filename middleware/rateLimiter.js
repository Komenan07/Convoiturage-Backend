const rateLimit = require('express-rate-limit');

/**
 * Configuration de base pour le rate limiting
 * Compatible avec express-rate-limit v6+
 */
const createBaseLimiter = (options = {}) => {
  const defaultOptions = {
    windowMs: 15 * 60 * 1000, // 15 minutes par dÃ©faut
    max: 100, // limite par dÃ©faut
    message: {
      success: false,
      message: 'Trop de requÃªtes, veuillez rÃ©essayer plus tard.'
    },
    standardHeaders: true,
    legacyHeaders: false,
    // Remplace onLimitReached (dÃ©prÃ©ciÃ©) par handler
    handler: (req, res) => {
      const retryAfter = Math.ceil((options.windowMs || 15 * 60 * 1000) / 1000);
      console.log(`Rate limit atteint - IP: ${req.ip}, Route: ${req.originalUrl}, User: ${req.user?._id || 'Non connectÃ©'}`);
      
      res.status(429).json({
        success: false,
        message: options.message?.message || 'Limite de requÃªtes atteinte',
        retryAfter: retryAfter,
        limit: options.max || 100,
        windowMs: options.windowMs || 15 * 60 * 1000
      });
    },
    skip: (req) => {
      // Whitelist pour certaines IPs (dÃ©veloppement, monitoring)
      const whitelistedIPs = process.env.RATE_LIMIT_WHITELIST?.split(',') || [];
      return whitelistedIPs.includes(req.ip);
    },
    keyGenerator: (req) => {
      // Par dÃ©faut utiliser l'IP, mais peut Ãªtre overridÃ©
      return req.ip;
    }
  };

  return rateLimit({ ...defaultOptions, ...options });
};

/**
 * Configuration des limites de taux par type d'opÃ©ration pour limiterTaux
 */
const rateLimitConfigs = {
  // Lecture standard
  lecture: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // 100 requÃªtes par fenÃªtre
    message: {
      success: false,
      message: 'Trop de requÃªtes de lecture, veuillez rÃ©essayer plus tard.'
    }
  },
  
  // Recherches (plus coÃ»teuses)
  recherche: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 50, // 50 recherches par fenÃªtre
    message: {
      success: false,
      message: 'Trop de recherches, veuillez rÃ©essayer plus tard.'
    }
  },
  
  // CrÃ©ation d'alertes d'urgence (trÃ¨s stricte)
  creation_urgence: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // Seulement 5 alertes d'urgence par fenÃªtre
    message: {
      success: false,
      message: 'Limite d\'alertes d\'urgence atteinte. Contactez les services d\'urgence directement si nÃ©cessaire.'
    }
  },
  
  // CrÃ©ation standard
  creation: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 10, // 10 crÃ©ations par fenÃªtre
    message: {
      success: false,
      message: 'Trop de crÃ©ations, veuillez rÃ©essayer plus tard.'
    }
  },
  
  // Modifications
  modification: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 30, // 30 modifications par fenÃªtre
    message: {
      success: false,
      message: 'Trop de modifications, veuillez rÃ©essayer plus tard.'
    }
  },
  
  // Actions diverses
  action: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 20, // 20 actions par fenÃªtre
    message: {
      success: false,
      message: 'Trop d\'actions, veuillez rÃ©essayer plus tard.'
    }
  },
  
  // Export (trÃ¨s limitÃ©)
  export: {
    windowMs: 60 * 60 * 1000, // 1 heure
    max: 5, // 5 exports par heure
    message: {
      success: false,
      message: 'Limite d\'exports atteinte, veuillez rÃ©essayer dans une heure.'
    }
  },
  
  // Administration
  admin: {
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 200, // 200 actions admin par fenÃªtre
    message: {
      success: false,
      message: 'Limite d\'actions administratives atteinte.'
    }
  },
  
  // Suppression (trÃ¨s restrictive)
  suppression: {
    windowMs: 60 * 60 * 1000, // 1 heure
    max: 10, // 10 suppressions par heure
    message: {
      success: false,
      message: 'Limite de suppressions atteinte, veuillez rÃ©essayer dans une heure.'
    }
  }
};

/**
 * Fonction limiterTaux compatible avec votre code existant
 * CrÃ©er un limiteur de taux basÃ© sur le type d'opÃ©ration
 * @param {string} type - Type d'opÃ©ration (lecture, creation, etc.)
 * @param {object} customConfig - Configuration personnalisÃ©e (optionnelle)
 * @returns {Function} Middleware de limitation de taux
 */
const limiterTaux = (type, customConfig = {}) => {
  // RÃ©cupÃ©rer la configuration par dÃ©faut pour ce type
  const defaultConfig = rateLimitConfigs[type] || rateLimitConfigs.lecture;
  
  // Fusionner avec la configuration personnalisÃ©e
  const config = {
    ...defaultConfig,
    ...customConfig
  };
  
  return rateLimit({
    windowMs: config.windowMs,
    max: config.max,
    message: config.message,
    standardHeaders: true, // Retourner les infos de limite dans les headers
    legacyHeaders: false, // DÃ©sactiver les anciens headers X-RateLimit-*
    
    // Fonction pour identifier les clients (par IP par dÃ©faut)
    keyGenerator: (req) => {
      // Si l'utilisateur est authentifiÃ©, utiliser son ID
      if (req.user && req.user.id) {
        return `user_${req.user.id}`;
      }
      // Sinon utiliser l'IP
      return req.ip;
    },
    
    // Fonction appelÃ©e quand la limite est dÃ©passÃ©e
    handler: (req, res) => {
      const retryAfter = Math.ceil(config.windowMs / 1000);
      
      console.warn(`ğŸš« Limite de taux atteinte:`, {
        type: type,
        key: req.ip,
        user: req.user?.id || 'anonyme',
        path: req.originalUrl,
        timestamp: new Date().toISOString()
      });
      
      // Log spÃ©cial pour les alertes d'urgence
      if (type === 'creation_urgence') {
        console.error(`ğŸš¨ LIMITE ALERTE URGENCE ATTEINTE par ${req.user?.id || req.ip}`);
      }
      
      res.status(429).json({
        success: false,
        message: config.message.message,
        retryAfter: retryAfter,
        limit: config.max,
        windowMs: config.windowMs
      });
    }
  });
};

/**
 * Rate limiter gÃ©nÃ©ral pour toutes les routes
 */
const generalLimiter = createBaseLimiter({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 200, // 200 requÃªtes par IP
  message: {
    success: false,
    message: 'Limite gÃ©nÃ©rale atteinte. Maximum 200 requÃªtes par 15 minutes.'
  }
});

/**
 * Rate limiter strict pour l'authentification
 */
const authLimiter = createBaseLimiter({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 tentatives de connexion par IP
  message: {
    success: false,
    message: 'Trop de tentatives de connexion. RÃ©essayez dans 15 minutes.'
  },
  skipSuccessfulRequests: true, // Ne compte que les Ã©checs
  handler: (req, res) => {
    console.log(`Tentatives de connexion multiples dÃ©tectÃ©es - IP: ${req.ip}, Email: ${req.body?.email || 'Non fourni'}`);
    res.status(429).json({
      success: false,
      message: 'Compte temporairement verrouillÃ© pour sÃ©curitÃ©. RÃ©essayez dans 15 minutes.',
      retryAfter: 900, // 15 minutes
      securityAlert: true
    });
  }
});

/**
 * Rate limiter pour la crÃ©ation de trajets
 */
const createTrajetLimiter = createBaseLimiter({
  windowMs: 60 * 60 * 1000, // 1 heure
  max: 10, // 10 trajets par heure par utilisateur
  message: {
    success: false,
    message: 'Limite de crÃ©ation de trajets atteinte. Maximum 10 trajets par heure.'
  },
  keyGenerator: (req) => {
    // Utiliser l'ID utilisateur pour les utilisateurs connectÃ©s
    return req.user ? `trajet_${req.user._id.toString()}` : `trajet_ip_${req.ip}`;
  },
  handler: (req, res) => {
    console.log(`Limite crÃ©ation trajets - User: ${req.user?._id || req.ip}`);
    res.status(429).json({
      success: false,
      message: 'Vous avez atteint la limite de crÃ©ation de trajets.',
      retryAfter: 3600, // 1 heure
      conseil: 'Planifiez vos trajets Ã  l\'avance pour Ã©viter cette limitation.'
    });
  }
});

/**
 * Rate limiter pour les rÃ©servations
 */
const reservationLimiter = createBaseLimiter({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 15, // 15 rÃ©servations par 10 minutes
  message: {
    success: false,
    message: 'Limite de rÃ©servations atteinte. Maximum 15 rÃ©servations par 10 minutes.'
  },
  keyGenerator: (req) => {
    return req.user ? `reservation_${req.user._id.toString()}` : `reservation_ip_${req.ip}`;
  }
});

/**
 * Rate limiter pour les messages de chat
 */
const messageLimiter = createBaseLimiter({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 30, // 30 messages par minute
  message: {
    success: false,
    message: 'Limite de messages atteinte. Maximum 30 messages par minute.'
  },
  keyGenerator: (req) => {
    return req.user ? `message_${req.user._id.toString()}` : `message_ip_${req.ip}`;
  },
  handler: (req, res) => {
    res.status(429).json({
      success: false,
      message: 'Vous envoyez trop de messages rapidement.',
      retryAfter: 60,
      conseil: 'Patientez un moment avant d\'envoyer d\'autres messages.'
    });
  }
});

/**
 * Rate limiter pour les recherches de trajets
 */
const searchLimiter = createBaseLimiter({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 60, // 60 recherches par minute
  message: {
    success: false,
    message: 'Trop de recherches. Maximum 60 recherches par minute.'
  },
  keyGenerator: (req) => {
    return req.user ? `search_${req.user._id.toString()}` : `search_ip_${req.ip}`;
  }
});

/**
 * Rate limiter pour les uploads de fichiers (photos, documents)
 */
const uploadLimiter = createBaseLimiter({
  windowMs: 60 * 60 * 1000, // 1 heure
  max: 20, // 20 uploads par heure
  message: {
    success: false,
    message: 'Limite d\'upload atteinte. Maximum 20 fichiers par heure.'
  },
  keyGenerator: (req) => {
    return req.user ? `upload_${req.user._id.toString()}` : `upload_ip_${req.ip}`;
  }
});

/**
 * Rate limiter spÃ©cial pour les alertes d'urgence
 */
const emergencyLimiter = createBaseLimiter({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 3, // 3 alertes d'urgence maximum par 5 minutes
  message: {
    success: false,
    message: 'Limite d\'alertes d\'urgence atteinte.'
  },
  keyGenerator: (req) => {
    return req.user ? `emergency_${req.user._id.toString()}` : `emergency_ip_${req.ip}`;
  },
  handler: (req, res) => {
    console.log(`ALERTE: Tentatives multiples d'alertes d'urgence - User: ${req.user?._id || req.ip}`);
    res.status(429).json({
      success: false,
      message: 'Trop d\'alertes d\'urgence envoyÃ©es.',
      retryAfter: 300,
      urgence: 'Si c\'est une vraie urgence, appelez directement les services d\'urgence: 110, 111, 112'
    });
  }
});

/**
 * Rate limiter pour les Ã©valuations
 */
const evaluationLimiter = createBaseLimiter({
  windowMs: 60 * 60 * 1000, // 1 heure
  max: 25, // 25 Ã©valuations par heure
  message: {
    success: false,
    message: 'Limite d\'Ã©valuations atteinte. Maximum 25 Ã©valuations par heure.'
  },
  keyGenerator: (req) => {
    return req.user ? `eval_${req.user._id.toString()}` : `eval_ip_${req.ip}`;
  }
});

/**
 * Rate limiter pour les signalements
 */
const reportLimiter = createBaseLimiter({
  windowMs: 60 * 60 * 1000, // 1 heure
  max: 5, // 5 signalements par heure maximum
  message: {
    success: false,
    message: 'Limite de signalements atteinte. Maximum 5 signalements par heure.'
  },
  keyGenerator: (req) => {
    return req.user ? `report_${req.user._id.toString()}` : `report_ip_${req.ip}`;
  },
  handler: (req, res) => {
    console.log(`Signalements multiples - User: ${req.user?._id || req.ip}`);
    res.status(429).json({
      success: false,
      message: 'Vous avez atteint la limite de signalements.',
      retryAfter: 3600,
      note: 'Les signalements abusifs peuvent entraÃ®ner des sanctions.'
    });
  }
});

/**
 * Rate limiter permissif pour les administrateurs
 */
const adminLimiter = createBaseLimiter({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 1000, // 1000 requÃªtes pour les admins
  message: {
    success: false,
    message: 'Limite administrative atteinte.'
  },
  keyGenerator: (req) => {
    return req.admin ? `admin_${req.admin._id.toString()}` : `admin_ip_${req.ip}`;
  }
});

/**
 * Rate limiter pour la vÃ©rification d'identitÃ©
 */
const verificationLimiter = createBaseLimiter({
  windowMs: 60 * 60 * 1000, // 1 heure
  max: 3, // 3 tentatives de vÃ©rification par heure
  message: {
    success: false,
    message: 'Limite de vÃ©rifications d\'identitÃ© atteinte. Maximum 3 tentatives par heure.'
  },
  keyGenerator: (req) => {
    return req.user ? `verify_${req.user._id.toString()}` : `verify_ip_${req.ip}`;
  }
});

/**
 * Rate limiter pour les paiements
 */
const paymentLimiter = createBaseLimiter({
  windowMs: 10 * 60 * 1000, // 10 minutes
  max: 10, // 10 tentatives de paiement par 10 minutes
  message: {
    success: false,
    message: 'Limite de transactions atteinte. Maximum 10 paiements par 10 minutes.'
  },
  keyGenerator: (req) => {
    return req.user ? `payment_${req.user._id.toString()}` : `payment_ip_${req.ip}`;
  },
  handler: (req, res) => {
    console.log(`Tentatives de paiement multiples - User: ${req.user?._id || req.ip}`);
    res.status(429).json({
      success: false,
      message: 'Trop de tentatives de paiement.',
      retryAfter: 600,
      securite: 'Pour votre sÃ©curitÃ©, patientez avant de rÃ©essayer.'
    });
  }
});

/**
 * Middleware adaptatif basÃ© sur le score de confiance utilisateur
 */
const adaptiveLimiter = (req, res, next) => {
  // Admin : limites trÃ¨s Ã©levÃ©es
  if (req.admin) {
    return adminLimiter(req, res, next);
  }
  
  // Utilisateur avec score de confiance Ã©levÃ©
  if (req.user && req.user.estVerifie && req.user.scoreConfiance >= 80) {
    const trustedUserLimiter = createBaseLimiter({
      windowMs: 15 * 60 * 1000,
      max: 300, // Limites Ã©levÃ©es pour utilisateurs de confiance
      message: {
        success: false,
        message: 'Limite atteinte (utilisateur vÃ©rifiÃ©).'
      },
      keyGenerator: (req) => `trusted_${req.user._id.toString()}`
    });
    return trustedUserLimiter(req, res, next);
  }
  
  // Utilisateur vÃ©rifiÃ© mais score moyen
  if (req.user && req.user.estVerifie && req.user.scoreConfiance >= 50) {
    const verifiedUserLimiter = createBaseLimiter({
      windowMs: 15 * 60 * 1000,
      max: 150, // Limites moyennes
      message: {
        success: false,
        message: 'Limite atteinte (utilisateur vÃ©rifiÃ©).'
      },
      keyGenerator: (req) => `verified_${req.user._id.toString()}`
    });
    return verifiedUserLimiter(req, res, next);
  }
  
  // Utilisateur connectÃ© mais non vÃ©rifiÃ© ou score faible
  if (req.user) {
    const basicUserLimiter = createBaseLimiter({
      windowMs: 15 * 60 * 1000,
      max: 80, // Limites rÃ©duites
      message: {
        success: false,
        message: 'Limite atteinte. VÃ©rifiez votre identitÃ© pour augmenter vos limites.'
      },
      keyGenerator: (req) => `basic_${req.user._id.toString()}`
    });
    return basicUserLimiter(req, res, next);
  }
  
  // Utilisateur non connectÃ© : limites les plus strictes
  return generalLimiter(req, res, next);
};

/**
 * Rate limiter spÃ©cifique pour les Ã©vÃ©nements
 */
const eventLimiter = createBaseLimiter({
  windowMs: 30 * 60 * 1000, // 30 minutes
  max: 50, // 50 requÃªtes liÃ©es aux Ã©vÃ©nements
  message: {
    success: false,
    message: 'Limite d\'accÃ¨s aux Ã©vÃ©nements atteinte.'
  },
  keyGenerator: (req) => {
    return req.user ? `event_${req.user._id.toString()}` : `event_ip_${req.ip}`;
  }
});

/**
 * Rate limiter pour les notifications
 */
const notificationLimiter = createBaseLimiter({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 20, // 20 notifications par 5 minutes
  message: {
    success: false,
    message: 'Limite de notifications atteinte.'
  },
  keyGenerator: (req) => {
    return req.user ? `notif_${req.user._id.toString()}` : `notif_ip_${req.ip}`;
  }
});

/**
 * Rate limiter pour les mises Ã  jour de profil
 */
const profileUpdateLimiter = createBaseLimiter({
  windowMs: 60 * 60 * 1000, // 1 heure
  max: 10, // 10 mises Ã  jour de profil par heure
  message: {
    success: false,
    message: 'Limite de mises Ã  jour de profil atteinte.'
  },
  keyGenerator: (req) => {
    return req.user ? `profile_${req.user._id.toString()}` : `profile_ip_${req.ip}`;
  }
});

/**
 * Rate limiter pour les conversations
 */
const conversationLimiter = createBaseLimiter({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 100, // 100 actions de conversation par minute
  message: {
    success: false,
    message: 'Limite d\'activitÃ© de conversation atteinte.'
  },
  keyGenerator: (req) => {
    return req.user ? `conv_${req.user._id.toString()}` : `conv_ip_${req.ip}`;
  }
});

/**
 * Rate limiter pour la gÃ©olocalisation
 */
const geoLimiter = createBaseLimiter({
  windowMs: 1 * 60 * 1000, // 1 minute
  max: 120, // 120 requÃªtes de gÃ©olocalisation par minute
  message: {
    success: false,
    message: 'Limite de requÃªtes de gÃ©olocalisation atteinte.'
  },
  keyGenerator: (req) => {
    return req.user ? `geo_${req.user._id.toString()}` : `geo_ip_${req.ip}`;
  }
});

/**
 * Rate limiter pour l'API publique (sans authentification)
 */
const publicApiLimiter = createBaseLimiter({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 50, // 50 requÃªtes pour l'API publique
  message: {
    success: false,
    message: 'Limite API publique atteinte. Connectez-vous pour des limites plus Ã©levÃ©es.'
  }
});

/**
 * Rate limiter spÃ©cial pour les opÃ©rations sensibles
 */
const sensitiveLimiter = createBaseLimiter({
  windowMs: 60 * 60 * 1000, // 1 heure
  max: 3, // 3 opÃ©rations sensibles par heure
  message: {
    success: false,
    message: 'Limite d\'opÃ©rations sensibles atteinte.'
  },
  keyGenerator: (req) => {
    return req.user ? `sensitive_${req.user._id.toString()}` : `sensitive_ip_${req.ip}`;
  },
  handler: (req, res) => {
    console.log(`SÃ‰CURITÃ‰: OpÃ©rations sensibles multiples - User: ${req.user?._id || req.ip}, Route: ${req.originalUrl}`);
    res.status(429).json({
      success: false,
      message: 'OpÃ©ration bloquÃ©e pour sÃ©curitÃ©.',
      retryAfter: 3600,
      contact: 'Contactez le support si vous pensez qu\'il s\'agit d\'une erreur.'
    });
  }
});

/**
 * Fonction principale rateLimiter (pour compatibilitÃ©)
 */
const rateLimiter = (options = {}) => {
  return createBaseLimiter(options);
};

// Export principal de la fonction rateLimiter
module.exports = rateLimiter;

// Export de la fonction limiterTaux (AJOUTÃ‰ POUR VOTRE COMPATIBILITÃ‰)
module.exports.limiterTaux = limiterTaux;

// Export des limiters prÃ©dÃ©finis
module.exports.general = generalLimiter;
module.exports.auth = authLimiter;
module.exports.createTrajet = createTrajetLimiter;
module.exports.reservation = reservationLimiter;
module.exports.message = messageLimiter;
module.exports.search = searchLimiter;
module.exports.upload = uploadLimiter;
module.exports.emergency = emergencyLimiter;
module.exports.evaluation = evaluationLimiter;
module.exports.report = reportLimiter;
module.exports.admin = adminLimiter;
module.exports.adaptive = adaptiveLimiter;
module.exports.event = eventLimiter;
module.exports.notification = notificationLimiter;
module.exports.profileUpdate = profileUpdateLimiter;
module.exports.conversation = conversationLimiter;
module.exports.geo = geoLimiter;
module.exports.publicApi = publicApiLimiter;
module.exports.sensitive = sensitiveLimiter;
module.exports.payment = paymentLimiter;
module.exports.verification = verificationLimiter;

// Alias pour diffÃ©rentes conventions de nommage
module.exports.authLimiter = authLimiter;
module.exports.createTrajetLimiter = createTrajetLimiter;
module.exports.reservationLimiter = reservationLimiter;
module.exports.messageLimiter = messageLimiter;
module.exports.searchLimiter = searchLimiter;
module.exports.uploadLimiter = uploadLimiter;
module.exports.emergencyLimiter = emergencyLimiter;
module.exports.evaluationLimiter = evaluationLimiter;
module.exports.reportLimiter = reportLimiter;
module.exports.adminLimiter = adminLimiter;
module.exports.adaptiveLimiter = adaptiveLimiter;